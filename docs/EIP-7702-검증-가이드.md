# EIP-7702 구현 검증 가이드

이 문서는 EIP-7702(EOA 코드 위임)가 올바르게 구현되었을 때 가능해야 하는 동작들과 이를 검증하는 로직에 대해 설명합니다.

> **참조:** 이 문서는 [EIP-7702 공식 사양](https://eips.ethereum.org/EIPS/eip-7702) 및 [eip7702.io](https://eip7702.io/) 문서를 기반으로 작성되었습니다.

## 목차

1. [EIP-7702 개요](#1-eip-7702-개요)
2. [구현 시 가능해야 하는 동작](#2-구현-시-가능해야-하는-동작)
3. [표준 준수 검증 체크리스트](#3-표준-준수-검증-체크리스트)
4. [검증 로직 상세 설명](#4-검증-로직-상세-설명)
5. [네트워크 테스트](#5-네트워크-테스트)
6. [보안 고려사항](#6-보안-고려사항)
7. [검증 결과 해석](#7-검증-결과-해석)
8. [생태계 및 도구](#8-생태계-및-도구)

---

## 1. EIP-7702 개요

### 1.1 기본 개념

EIP-7702는 외부 소유 계정(EOA)이 스마트 컨트랙트의 코드를 임시로 위임받아 실행할 수 있게 하는 이더리움 개선 제안입니다. 2025년 5월 7일 Pectra 업그레이드에서 이더리움 메인넷에 배포되었습니다.

### 1.2 핵심 구성요소

| 구성요소 | 값 | 설명 |
|---------|-----|------|
| `DELEGATION_PREFIX` | `0xef0100` | 위임 지시자(Delegation Designator)의 3바이트 접두사 |
| `DELEGATION_CODE_LENGTH` | 23 | 위임 코드 전체 길이 (접두사 3 + 주소 20) |
| `MAGIC` | `0x05` | 권한 부여 서명 시 사용되는 도메인 분리자 |
| `SET_CODE_TX_TYPE` | `0x04` | EIP-7702 트랜잭션 타입 |
| `PER_EMPTY_ACCOUNT_COST` | 25,000 | 새 계정당 가스 비용 |
| `PER_AUTH_BASE_COST` | 12,500 | 기존 계정 환불 금액 |
| `COLD_ACCOUNT_READ_COST` | 2,600 | 콜드 계정 접근 가스 (EIP-2929) |
| `WARM_STORAGE_READ_COST` | 100 | 웜 계정 접근 가스 |

### 1.3 권한 부여 튜플 구조 (Authorization Tuple)

공식 사양에 따른 권한 부여 튜플 형식:

```
authorization_tuple = [chain_id, address, nonce, y_parity, r, s]
```

| 필드 | 타입 | 설명 |
|------|------|------|
| `chain_id` | uint256 | 체인 ID (0 = 모든 체인 허용, 와일드카드) |
| `address` | address | 위임받을 컨트랙트 주소 |
| `nonce` | uint64 | 권한 부여자의 논스 (2^64-1 미만) |
| `y_parity` | uint8 | 서명 Y 패리티 (0 또는 1) |
| `r` | uint256 | 서명 R 값 |
| `s` | uint256 | 서명 S 값 (secp256k1n/2 이하, EIP-2 준수) |

### 1.4 서명 해시 계산

```
msg = keccak256(MAGIC || rlp([chain_id, address, nonce]))
    = keccak256(0x05 || rlp([chain_id, address, nonce]))
```

### 1.5 SetCode 트랜잭션 구조

```
TransactionType = 0x04
TransactionPayload = rlp([
    chain_id,
    nonce,
    max_priority_fee_per_gas,
    max_fee_per_gas,
    gas_limit,
    destination,
    value,
    data,
    access_list,
    authorization_list,
    signature_y_parity,
    signature_r,
    signature_s
])
```

---

## 2. 구현 시 가능해야 하는 동작

EIP-7702가 올바르게 구현되면 다음 동작들이 가능해야 합니다.

### 2.1 위임 지시자 설정

**동작 설명:**
- EOA가 특정 스마트 컨트랙트에 코드 실행을 위임할 수 있어야 합니다
- 위임 후 EOA의 코드는 `0xef0100 || address` 형태로 설정됩니다

**검증 포인트:**
```
EOA 코드 = 0xef0100 + 20바이트 컨트랙트 주소
총 길이 = 23바이트
```

**예시:**
```
대상 컨트랙트: 0xA6E8CF0671563914489F2eC2436CeBCcD17B7A85
위임 코드: 0xef0100a6e8cf0671563914489f2ec2436cebccd17b7a85
```

**특수 케이스 - 위임 해제:**
```
대상 주소 = 0x0000000000000000000000000000000000000000
→ 코드가 작성되지 않고, 기존 위임이 해제됨
→ 코드 해시가 빈 코드 해시(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470)로 재설정
```

### 2.2 권한 부여 서명 및 복구

**동작 설명:**
- EOA 소유자가 위임 권한을 부여하는 서명을 생성할 수 있어야 합니다
- 서명에서 원래 권한 부여자(Authority)를 복구할 수 있어야 합니다

**검증 포인트:**
1. MAGIC 값 `0x05`가 서명 해시 계산에 사용되어야 함
2. 서명 해시가 `keccak256(0x05 || rlp([chain_id, address, nonce]))` 형식으로 계산되어야 함
3. `s` 값이 `secp256k1n/2` 이하여야 함 (EIP-2 준수)
4. `ecrecover`로 복구된 주소가 원래 EOA 주소와 일치해야 함
5. ChainID가 0인 경우 모든 체인에서 유효해야 함

### 2.3 SetCode 트랜잭션 전송

**동작 설명:**
- 타입 `0x04`의 새로운 트랜잭션 형식을 지원해야 합니다
- 트랜잭션에 권한 부여 목록(authorization_list)이 포함되어야 합니다

**검증 포인트:**
1. **필수:** 권한 부여 목록이 최소 1개 이상 있어야 함 (빈 목록 거부)
2. 트랜잭션 체인 ID와 권한 부여 체인 ID가 일치해야 함 (또는 와일드카드 0)
3. 각 권한 부여의 `nonce`가 `2^64 - 1` 미만이어야 함
4. 충분한 가스가 제공되어야 함

### 2.4 위임을 통한 함수 실행

**동작 설명:**
- 위임이 설정된 EOA에 트랜잭션을 보내면 대상 컨트랙트의 코드가 실행되어야 합니다
- EOA의 상태(잔액, 스토리지)가 컨트랙트 코드의 컨텍스트로 사용됩니다

**검증 포인트:**
1. `CALL`, `CALLCODE`, `DELEGATECALL`, `STATICCALL` 시 위임 주소의 코드가 실행됨
2. `msg.sender`는 트랜잭션 발신자
3. `address(this)`는 EOA 주소
4. 배치 실행, 멀티시그 등 컨트랙트 기능이 EOA에서 동작

**EVM 동작 변경사항:**

| 연산코드 | 동작 |
|---------|------|
| `EXTCODESIZE` | 23 반환 (위임 지시자 크기) |
| `EXTCODECOPY` | 위임 지시자 자체 반환 |
| `EXTCODEHASH` | 위임 지시자의 해시 반환 |
| `CODESIZE` | 위임 대상 컨트랙트의 코드 크기 반환 |
| `CODECOPY` | 위임 대상 컨트랙트의 코드 반환 |

### 2.5 가스 계산

**Intrinsic 가스 계산 공식 (EIP-2930 상속):**
```
intrinsic_gas = 21,000                                    // 기본 트랜잭션
              + 16 × (비0 calldata 바이트 수)
              + 4 × (0 calldata 바이트 수)
              + 2,400 × (액세스 리스트 주소 수)
              + 1,900 × (액세스 리스트 스토리지 키 수)
              + 25,000 × (권한 부여 목록 길이)          // PER_EMPTY_ACCOUNT_COST
```

**환불 메커니즘:**
- 기존 계정에 대해서는 `PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST = 12,500` 가스가 글로벌 환불 카운터에 추가
- 최악의 경우 비용을 먼저 청구하고, 나중에 환불 적용

**위임 코드 해석 시 추가 비용:**
- 콜드 계정 접근: 2,600 가스 (COLD_ACCOUNT_READ_COST)
- 웜 계정 접근: 100 가스 (WARM_STORAGE_READ_COST)

---

## 3. 표준 준수 검증 체크리스트

EIP-7702 표준 완벽 준수를 위해 다음 항목들을 모두 검증해야 합니다.

### 3.1 권한 부여 튜플 검증 (8단계)

각 권한 부여 튜플에 대해 다음 순서로 검증:

| 단계 | 검증 항목 | 실패 시 동작 |
|-----|----------|-------------|
| 1 | 체인 ID가 0이거나 현재 네트워크 ID와 일치 | 다음 튜플로 건너뜀 |
| 2 | 논스가 `2^64 - 1` 미만 | 다음 튜플로 건너뜀 |
| 3 | `ecrecover(msg, y_parity, r, s)`로 authority 복구 | 다음 튜플로 건너뜀 |
| 4 | `s` 값이 `secp256k1n/2` 이하 (EIP-2) | 다음 튜플로 건너뜀 |
| 5 | authority를 `accessed_addresses`에 추가 (EIP-2929) | - |
| 6 | authority의 코드가 비어있거나 이미 위임됨 | 다음 튜플로 건너뜀 |
| 7 | authority의 논스가 권한 부여 논스와 일치 | 다음 튜플로 건너뜀 |
| 8 | authority의 코드를 `0xef0100 \|\| address`로 설정 | - |

**중요:**
- 유효하지 않은 튜플은 처리를 중단하고 다음 튜플로 계속 진행
- 트랜잭션 실행 실패 시에도 위임 지시자는 롤백되지 않음
- 같은 authority의 여러 튜플이 있으면 마지막 유효한 튜플 사용

### 3.2 트랜잭션 검증

| 검증 항목 | 요구사항 | 비고 |
|----------|---------|------|
| 트랜잭션 타입 | `0x04` | SET_CODE_TX_TYPE |
| 권한 목록 | 비어있지 않음 | 빈 목록은 유효하지 않음 |
| 가스 한도 | intrinsic 가스 이상 | 모든 권한 부여에 대해 최악의 경우 비용 포함 |
| destination | nil 불가 | 컨트랙트 생성 불가 |

### 3.3 서명 검증

| 검증 항목 | 요구사항 |
|----------|---------|
| MAGIC 접두사 | `0x05` 사용 |
| RLP 인코딩 | `rlp([chain_id, address, nonce])` |
| s 값 범위 | `s <= secp256k1n/2` (EIP-2) |
| y_parity | 0 또는 1 |

### 3.4 위임 지시자 검증

| 검증 항목 | 요구사항 |
|----------|---------|
| 접두사 | `0xef0100` (정확히 3바이트) |
| 총 길이 | 23바이트 |
| 주소 | 유효한 20바이트 이더리움 주소 |
| 0xef 사용 | EIP-3541에서 금지된 opcode 사용으로 일반 배포 불가 |

---

## 4. 검증 로직 상세 설명

### 4.1 위임(Delegation) 검증

위임 코드가 올바른 형식인지 검증합니다.

#### 검증 항목

| 검증 항목 | 설명 | 예상 결과 |
|----------|------|----------|
| 길이 검증 | 코드 길이가 정확히 23바이트인지 | 23바이트여야 함 |
| 접두사 검증 | 첫 3바이트가 `0xef0100`인지 | `0xef0100`이어야 함 |
| 주소 파싱 | 나머지 20바이트가 유효한 주소인지 | 유효한 이더리움 주소 |

#### 테스트 케이스

```go
// 유효한 케이스
"valid_simple_delegation"     // 0xef0100 + 20바이트 주소 → 통과

// 무효한 케이스
"wrong_address_size_19"       // 주소가 19바이트 → 실패
"short_address_1_byte"        // 주소가 1바이트만 → 실패
"long_address_21_bytes"       // 주소가 21바이트 → 실패
"wrong_prefix_size_2"         // 접두사가 2바이트만 → 실패
"wrong_prefix_ef0101"         // 잘못된 접두사 → 실패
"wrong_prefix_ef0000"         // 잘못된 접두사 → 실패
"no_prefix_address_only"      // 접두사 없음 → 실패
"prefix_only_no_address"      // 주소 없음 → 실패
"empty_input"                 // 빈 입력 → 실패
"nil_input"                   // nil 입력 → 실패
```

### 4.2 권한 부여(Authorization) 검증

권한 부여 튜플의 서명과 구조를 검증합니다.

#### 검증 항목

| 검증 항목 | 설명 | 예상 결과 |
|----------|------|----------|
| 체인 ID 검증 | 체인 ID가 일치하거나 0(와일드카드)인지 | 일치 또는 와일드카드 |
| 논스 범위 | 논스가 `2^64 - 1` 미만인지 | 범위 내 |
| 서명 s 값 | `s <= secp256k1n/2` (EIP-2) | 범위 내 |
| 서명 유효성 | 서명에서 공개키를 복구할 수 있는지 | 복구 가능 |
| 권한 부여자 일치 | 복구된 주소가 예상 주소와 일치하는지 | 일치해야 함 |
| 계정 상태 | 코드가 비어있거나 이미 위임됨 | 조건 충족 |

#### 테스트 케이스

```go
// 유효한 케이스
"valid_auth_chain_1"    // 체인 ID 1에 대한 정상 권한 부여
"valid_auth_with_nonce" // 논스 5인 권한 부여
"wildcard_chain_id"     // 체인 ID 0 (모든 체인)
"high_nonce"            // 최대 uint64 논스

// 서명 검증 과정
1. SigHash 계산: keccak256(0x05 || rlp([chainID, address, nonce]))
2. 서명 생성: Sign(privateKey, sigHash)
3. 권한 부여자 복구: ecrecover(sigHash, y_parity, r, s)
4. 주소 비교: 복구된 주소 == 예상 주소
```

### 4.3 SetCode 트랜잭션 검증

EIP-7702 트랜잭션 구조와 유효성을 검증합니다.

#### 검증 항목

| 검증 항목 | 설명 | 예상 결과 |
|----------|------|----------|
| 권한 목록 존재 | AuthList가 비어있지 않은지 | 최소 1개 이상 |
| 체인 ID 일치 | 트랜잭션과 권한 부여의 체인 ID 일치 | 일치 필요 |
| 가스 충분성 | 제공된 가스가 필요량 이상인지 | 충분해야 함 |
| 권한 부여 유효성 | 각 권한 부여가 개별적으로 유효한지 | 모두 유효 |
| destination 필드 | nil이 아닌지 | 설정되어야 함 |

#### 테스트 케이스

```go
// 무효한 케이스
"empty_auth_list"       // 빈 권한 목록 → 실패
                        // 오류: "EIP-7702 transaction with empty auth list"

// 유효한 케이스
"valid_single_auth"     // 단일 권한 부여
"valid_multiple_auths"  // 복수 권한 부여 (와일드카드 포함)
"insufficient_gas"      // 가스 부족 (구조적으론 유효)
```

### 4.4 가스 계산 검증

intrinsic 가스 계산이 EIP-7702 사양에 맞는지 검증합니다.

#### 가스 상수

| 상수 | 값 | 설명 |
|-----|-----|------|
| TxGas | 21,000 | 기본 트랜잭션 가스 |
| TxDataZeroGas | 4 | 0바이트당 가스 |
| TxDataNonZeroGas | 16 | 비0바이트당 가스 |
| TxAccessListAddressGas | 2,400 | 액세스 리스트 주소당 가스 |
| TxAccessListStorageKeyGas | 1,900 | 스토리지 키당 가스 |
| PerAuthNewAccountGas | 25,000 | 신규 계정 권한 부여 가스 |
| PerAuthExistingRefund | 12,500 | 기존 계정 환불 |
| ColdAccountReadCost | 2,600 | 콜드 계정 접근 가스 |
| WarmStorageReadCost | 100 | 웜 계정 접근 가스 |

#### 테스트 케이스

```go
// 테스트 케이스별 예상 가스
"single_new_auth":
  = 21,000 (기본) + 25,000 (1 신규 권한) = 46,000

"single_existing_auth":
  = 21,000 + 25,000 - 12,500 (환불) = 33,500

"two_auths_mixed":
  = 21,000 + 50,000 (2 권한) - 12,500 (1 환불) = 58,500

"auth_with_data" (0바이트 2개, 비0바이트 2개):
  = 21,000 + 25,000 + (2×4) + (2×16) = 46,040
```

---

## 5. 네트워크 테스트

라이브 네트워크(예: Sepolia 테스트넷)에서 EIP-7702 동작을 검증합니다.

### 5.1 Pectra 포크 지원 확인

**목적:** 네트워크가 EIP-7702를 포함한 Pectra 포크를 지원하는지 확인

**검증 방법:**
1. `eth_chainId` RPC 호출로 체인 ID 확인
2. `eth_getBlockByNumber`로 최신 블록 조회
3. 네트워크 연결 상태 확인

**지원 네트워크 (2025년 기준):**
- Ethereum Mainnet (2025년 5월 7일 이후)
- Sepolia Testnet
- Hoodi Testnet

### 5.2 잔액 확인

**목적:** 테스트 계정에 충분한 잔액이 있는지 확인

**검증 방법:**
1. `eth_getBalance` RPC 호출
2. 잔액 > 0 확인

### 5.3 SetCode 트랜잭션 테스트

**목적:** EIP-7702 SetCode 트랜잭션이 네트워크에서 처리되는지 확인

**테스트 흐름:**

```
1. 현재 논스 조회
   └─ eth_getTransactionCount

2. 권한 부여 생성 및 서명
   └─ 중요: self-broadcast 시 auth.nonce = tx.nonce + 1

3. 가스 가격 조회
   └─ eth_gasPrice, eth_maxPriorityFeePerGas

4. SetCode 트랜잭션 생성
   └─ Type: 0x04
   └─ To: 자신의 주소
   └─ AuthList: [서명된 권한 부여]

5. 트랜잭션 서명 및 전송
   └─ eth_sendRawTransaction

6. 결과 확인
   └─ 트랜잭션 해시 반환
```

**논스 처리 주의사항:**
- Self-broadcast 시 트랜잭션이 처리될 때 계정 논스가 **먼저** 증가합니다
- 권한 부여 목록은 **발신자 논스 증가 후** 처리됩니다
- 따라서 권한 부여의 논스는 `현재 논스 + 1`이어야 합니다

### 5.4 위임 코드 확인

**목적:** SetCode 트랜잭션 후 위임 코드가 올바르게 설정되었는지 확인

**검증 방법:**
1. `eth_getCode` RPC 호출로 EOA 코드 조회
2. 코드 길이가 23바이트인지 확인
3. 접두사가 `0xef0100`인지 확인
4. 대상 주소가 예상과 일치하는지 확인

**위임 계정 탐지 방법:**
```javascript
const code = await provider.getCode(address);
if (code.startsWith('0xef0100')) {
    // 위임된 스마트 계정
    const delegateAddress = '0x' + code.slice(8);
}
```

### 5.5 배치 실행 테스트

**목적:** 위임된 컨트랙트 기능이 EOA에서 동작하는지 확인

**테스트 흐름:**

```
1. 위임 상태 확인
   └─ eth_getCode로 위임 코드 존재 확인

2. 배치 호출 데이터 인코딩
   └─ executeBatch(address[], uint256[], bytes[])
   └─ 함수 선택자: keccak256("executeBatch(address[],uint256[],bytes[])")[:4]

3. EIP-1559 트랜잭션 생성
   └─ Type: 0x02
   └─ To: 자신의 주소 (위임된 EOA)
   └─ Data: 인코딩된 배치 호출

4. 트랜잭션 전송 및 결과 확인
```

---

## 6. 보안 고려사항

### 6.1 깨지는 불변식 (Broken Invariants)

EIP-7702는 이더리움의 세 가지 핵심 불변식을 변경합니다:

| 기존 불변식 | EIP-7702 이후 |
|------------|--------------|
| 계정 잔액은 해당 계정의 트랜잭션으로만 감소 | 위임된 계정은 누구나 호출하여 잔액 감소 가능 |
| EOA 논스는 트랜잭션 실행 시작 후 증가하지 않음 | 위임된 계정은 실행 중 CREATE로 논스 증가 가능 |
| `tx.origin == msg.sender`는 최상위 프레임에서만 참 | 위임된 계정이 자신을 호출하면 이 조건이 참이 됨 |

### 6.2 권한 부여 서명 보안

**위험:** EIP-7702 권한 부여 서명은 계정 탈취에 사용될 수 있습니다.

**필수 검증 항목 (위임 컨트랙트 개발자):**
- 재생 공격 방지를 위한 논스 검증
- `value` 필드 검증
- `gas` 제한 검증
- 대상/calldata 검증

```solidity
// 권장: 각 User Operation에 대해 EOA 서명 검증
function validateUserOp(UserOperation calldata op) external {
    address signer = ecrecover(
        keccak256(abi.encodePacked(op.sender, op.nonce, op.callData)),
        op.signature.v, op.signature.r, op.signature.s
    );
    require(signer == owner, "Invalid signature");
}
```

### 6.3 초기화 보안

**문제점:** EIP-7702는 initcode나 스토리지 초기화를 제공하지 않습니다.

**위험:**
- 관찰자가 권한 부여 서명을 프론트러닝하여 자신의 초기화 로직 실행 가능
- 사전 배포된 스마트 컨트랙트 지갑은 취약할 수 있음

**해결책:**
```solidity
// 초기 calldata에 대해 EOA 키로 ecrecover 검증
function initialize(bytes calldata initData, bytes calldata signature) external {
    require(!initialized, "Already initialized");
    address signer = ecrecover(keccak256(initData), ...);
    require(signer == address(this), "Must be signed by EOA");
    // 초기화 진행...
    initialized = true;
}
```

### 6.4 스토리지 충돌

**문제점:** 여러 위임 컨트랙트 간 스토리지 충돌 가능

**해결책:**
- [ERC-7201](https://eips.ethereum.org/EIPS/eip-7201) 네임스페이스 공식 사용
- [ERC-7779](https://eips.ethereum.org/EIPS/eip-7779) (초안) 재위임 표준 프로세스 따르기

### 6.5 트랜잭션 풀 고려사항

**권장사항:**
- 0이 아닌 위임 지시자가 있는 EOA에 대해 하나의 미결 트랜잭션만 수락
- 위임된 계정의 잔액이 언제든 소진될 수 있으므로 정적 유효성 검사 불가

### 6.6 화이트리스트 우회 공격

**위험:** 화이트리스트된 주소가 위임한 프록시를 통해 우회 가능

**해결책:**
- EOA 차단 대신 논리적 제약 적용 (최소 시간 지연, 수수료, 불변식)
- 재진입 보호는 CEI 패턴 또는 재진입 가드 사용

### 6.7 논스 재사용 문제

**현재 동작:**
- 권한 부여 논스가 트랜잭션 간 재사용될 수 있음
- 임의의 논스 값(과거/미래)이 수락될 수 있음

**권장사항:**
- 애플리케이션 레벨에서 강력한 논스 추적 구현
- 프로토콜과 애플리케이션 레이어 간 책임 경계 이해

---

## 7. 검증 결과 해석

### 7.1 컴포넌트별 상태

| 컴포넌트 | 통과 조건 | 실패 시 의미 |
|---------|----------|-------------|
| Delegation | 모든 위임 테스트 통과 | 위임 코드 파싱/생성 오류 |
| Authorization | 모든 권한 부여 테스트 통과 | 서명 또는 복구 로직 오류 |
| Transaction | 모든 트랜잭션 테스트 통과 | 트랜잭션 구조 검증 오류 |
| Gas Calculation | 모든 가스 테스트 통과 | 가스 계산 로직 오류 |

### 7.2 일반적인 오류와 원인

#### "invalid delegation length"
- **원인:** 위임 코드 길이가 23바이트가 아님
- **해결:** 접두사 3바이트 + 주소 20바이트 = 23바이트 확인

#### "invalid delegation prefix"
- **원인:** 접두사가 `0xef0100`이 아님
- **해결:** 위임 코드 생성 로직 확인

#### "chain ID mismatch"
- **원인:** 트랜잭션과 권한 부여의 체인 ID 불일치
- **해결:** 같은 체인 ID 사용 또는 와일드카드 0 사용

#### "EIP-7702 transaction with empty auth list"
- **원인:** 권한 부여 목록이 비어있음
- **해결:** 최소 1개 이상의 권한 부여 포함

#### "failed to recover authority"
- **원인:** 서명에서 공개키 복구 실패
- **해결:** 서명 생성 로직 및 SigHash 계산 확인

#### "invalid s value"
- **원인:** 서명의 s 값이 `secp256k1n/2`를 초과
- **해결:** EIP-2 준수 서명 생성 로직 사용

#### "code already set"
- **원인:** authority의 코드가 이미 설정되어 있고 위임이 아님
- **해결:** 빈 코드 또는 기존 위임만 재위임 가능

### 7.3 네트워크 오류

#### "RPC error -32000: typed transaction too short"
- **원인:** 트랜잭션 인코딩 오류
- **해결:** RLP 인코딩 및 타입 바이트 프리픽스 확인

#### "nonce too low" 또는 "nonce too high"
- **원인:** 권한 부여 논스가 올바르지 않음
- **해결:** Self-broadcast 시 `auth.nonce = tx.nonce + 1` 확인

#### "insufficient funds"
- **원인:** 잔액 부족
- **해결:** 테스트 계정에 충분한 ETH 충전

#### "authorization list must not be empty"
- **원인:** 트랜잭션에 권한 부여가 없음
- **해결:** 최소 1개 이상의 권한 부여 포함

---

## 8. 생태계 및 도구

### 8.1 개발 라이브러리

| 라이브러리 | 언어 | 링크 |
|-----------|------|------|
| viem | TypeScript | [viem.sh/docs/eip7702](https://viem.sh/docs/eip7702) |
| ethers.js v6 | JavaScript | [ethers.org](https://docs.ethers.org) |
| go-ethereum | Go | [github.com/ethereum/go-ethereum](https://github.com/ethereum/go-ethereum) |
| alloy | Rust | [github.com/alloy-rs/alloy](https://github.com/alloy-rs/alloy) |

### 8.2 지원 지갑

| 지갑 | 상태 | 비고 |
|-----|------|------|
| MetaMask | 지원 예정 | 스마트 계정 통합 |
| Safe | 지원 | [docs.safe.global](https://docs.safe.global/advanced/eip-7702/overview) |
| Ambire | 지원 | 네이티브 EIP-7702 |

### 8.3 관련 EIP/ERC

| 번호 | 제목 | 관계 |
|-----|------|------|
| EIP-2929 | 상태 접근 가스 비용 | 가스 계산 기반 |
| EIP-2930 | 액세스 리스트 | 트랜잭션 형식 상속 |
| EIP-3541 | 0xef 코드 거부 | 위임 지시자 보호 |
| ERC-4337 | 계정 추상화 | 호환성 |
| ERC-7201 | 네임스페이스 스토리지 | 스토리지 충돌 방지 |
| ERC-7779 | 재위임 표준 | 안전한 재위임 |

---

## 부록: 참조 구현

### A. 공식 사양
- [EIP-7702 공식 문서](https://eips.ethereum.org/EIPS/eip-7702)
- [eip7702.io](https://eip7702.io/)

### B. go-ethereum 참조 파일
- `core/types/tx_setcode.go`: 핵심 EIP-7702 구현
- `core/types/tx_setcode_test.go`: 위임 파싱 테스트
- `core/blockchain_test.go`: 통합 테스트

### C. reth 참조 파일
- `crates/transaction-pool/src/error.rs`: EIP-7702 오류 타입
- `crates/storage/codecs/src/alloy/authorization_list.rs`: 권한 인코딩
- `crates/payload/validator/src/prague.rs`: Prague 검증

### D. 추가 리소스
- [QuickNode EIP-7702 가이드](https://www.quicknode.com/guides/ethereum-development/smart-contracts/eip-7702-smart-accounts)
- [Halborn 보안 고려사항](https://www.halborn.com/blog/post/eip-7702-security-considerations)
- [SlowMist 모범 사례](https://slowmist.medium.com/in-depth-discussion-on-eip-7702-and-best-practices-968b6f57c0d5)
- [HackMD 구현 가이드](https://hackmd.io/@nachomazzara/eip7702-almost-low-level-guide)
