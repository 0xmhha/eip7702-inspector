# EIP-7702 Inspector 구현 분석 리포트

이 문서는 현재 EIP-7702 Inspector 코드가 EIP-7702 표준을 얼마나 검증할 수 있는지 분석한 결과입니다.

## 분석 개요

| 영역 | 구현 상태 | 커버리지 | 파일 |
|-----|----------|---------|------|
| 위임(Delegation) 검증 | ✅ 완료 | 100% | `delegation.go` |
| 권한 부여(Authorization) 검증 | ⚠️ 부분 | ~50% | `authorization.go` |
| 트랜잭션 검증 | ⚠️ 부분 | ~70% | `transaction.go` |
| 가스 계산 | ⚠️ 부분 | ~80% | `gas.go` |
| 네트워크 테스트 | ✅ 완료 | 100% | `network.go` |
| 상수 정의 | ✅ 완료 | 100% | `constants.go` |

---

## 1. 위임(Delegation) 검증 ✅ 완료

### 구현 현황

`delegation.go`에서 위임 지시자(Delegation Designator) 검증이 완벽하게 구현되어 있습니다.

### 구현된 기능

| 기능 | 함수 | 상태 |
|-----|------|------|
| 위임 코드 길이 검증 | `VerifyDelegation()` | ✅ |
| 접두사 검증 (`0xef0100`) | `VerifyDelegation()` | ✅ |
| 주소 파싱 | `ParseDelegation()` | ✅ |
| 주소 → 위임 코드 변환 | `AddressToDelegation()` | ✅ |
| 위임 여부 확인 | `IsDelegation()` | ✅ |

### 테스트 케이스 (11개)

```go
✅ valid_simple_delegation      // 정상 위임 코드
✅ wrong_address_size_19        // 주소 19바이트 (실패)
✅ short_address_1_byte         // 주소 1바이트 (실패)
✅ long_address_21_bytes        // 주소 21바이트 (실패)
✅ wrong_prefix_size_2          // 접두사 2바이트 (실패)
✅ wrong_prefix_ef0101          // 잘못된 접두사 (실패)
✅ wrong_prefix_ef0000          // 잘못된 접두사 (실패)
✅ no_prefix_address_only       // 접두사 없음 (실패)
✅ prefix_only_no_address       // 주소 없음 (실패)
✅ empty_input                  // 빈 입력 (실패)
✅ nil_input                    // nil 입력 (실패)
```

### 누락 항목

**없음** - 위임 검증은 완벽하게 구현됨

---

## 2. 권한 부여(Authorization) 검증 ⚠️ 부분 구현

### 구현 현황

`authorization.go`에서 기본적인 권한 부여 검증이 구현되어 있으나, EIP-7702 사양의 8단계 검증 중 일부가 누락되어 있습니다.

### 구현된 기능

| 기능 | 함수 | 상태 |
|-----|------|------|
| MAGIC 접두사 `0x05` 사용 | `SigHash()` | ✅ |
| RLP 인코딩 | `prefixedRlpHash()` | ✅ |
| 서명 해시 계산 | `SigHash()` | ✅ |
| Authority 복구 (ecrecover) | `Authority()` | ✅ |
| 체인 ID 검증 (와일드카드 0 지원) | `VerifyAuthorization()` | ✅ |
| 서명 생성 | `SignSetCode()` | ✅ |

### 테스트 케이스 (4개)

```go
✅ valid_auth_chain_1     // 체인 ID 1 정상 권한 부여
✅ valid_auth_with_nonce  // 논스 5인 권한 부여
✅ wildcard_chain_id      // 체인 ID 0 (와일드카드)
✅ high_nonce             // 최대 uint64 논스
```

### 누락된 검증 항목

#### 높은 우선순위 (보안 관련)

| 항목 | EIP-7702 요구사항 | 현재 상태 | 위험도 |
|-----|------------------|----------|-------|
| s 값 범위 검증 | `s <= secp256k1n/2` (EIP-2 준수) | ❌ 미구현 | 🔴 높음 |
| y_parity 검증 | 0 또는 1만 허용 | ❌ 미구현 | 🟡 중간 |
| 논스 범위 검증 | `nonce < 2^64 - 1` | ❌ 미구현 | 🟡 중간 |

#### 네트워크 상태 의존 (런타임 검증)

| 항목 | EIP-7702 요구사항 | 현재 상태 |
|-----|------------------|----------|
| 계정 코드 상태 검증 | 코드가 비어있거나 이미 위임됨 | ❌ 미구현 |
| 논스 일치 검증 | authority 논스 == auth 논스 | ❌ 미구현 |
| accessed_addresses 추가 | EIP-2929 준수 | ❌ 미구현 |

### 권장 추가 구현

```go
// s 값 범위 검증 (EIP-2)
func ValidateSignatureS(s *uint256.Int) bool {
    // secp256k1n/2 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
    halfN, _ := uint256.FromHex("0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0")
    return s.Cmp(halfN) <= 0
}

// y_parity 검증
func ValidateYParity(v uint8) bool {
    return v == 0 || v == 1
}

// 논스 범위 검증
func ValidateNonce(nonce uint64) bool {
    return nonce < (1<<64 - 1)  // nonce < 2^64 - 1
}
```

---

## 3. SetCode 트랜잭션 검증 ⚠️ 부분 구현

### 구현 현황

`transaction.go`에서 SetCode 트랜잭션 구조 검증이 구현되어 있습니다.

### 구현된 기능

| 기능 | 함수 | 상태 |
|-----|------|------|
| 빈 권한 목록 거부 | `VerifySetCodeTx()` | ✅ |
| 체인 ID 일치 검증 | `VerifySetCodeTx()` | ✅ |
| Intrinsic 가스 계산 | `CalculateIntrinsicGas()` | ✅ |
| 가스 충분성 검증 | `VerifySetCodeTx()` | ✅ |
| 각 권한 부여 개별 검증 | `VerifySetCodeTx()` | ✅ |

### 테스트 케이스 (4개)

```go
✅ empty_auth_list       // 빈 권한 목록 → 실패
✅ valid_single_auth     // 단일 권한 부여
✅ valid_multiple_auths  // 복수 권한 부여
✅ insufficient_gas      // 가스 부족 (구조적으론 유효)
```

### 누락된 검증 항목

| 항목 | EIP-7702 요구사항 | 현재 상태 | 비고 |
|-----|------------------|----------|------|
| destination nil 검증 | 컨트랙트 생성 불가 | ⚠️ 부분 | zero address 허용됨 |
| 중복 authority 처리 | 마지막 유효 튜플만 사용 | ❌ 미구현 | |
| 유효하지 않은 튜플 스킵 | 실패 시 다음 튜플로 건너뜀 | ❌ 미구현 | 현재는 즉시 실패 |
| 트랜잭션 타입 검증 | `0x04` 확인 | ❌ 미구현 | 구조체에만 정의됨 |

### 현재 동작 vs 사양

**현재 동작:**
```go
// 권한 부여 하나라도 실패하면 전체 실패
for i := range tx.AuthList {
    result.AuthVerifications[i] = VerifyAuthorization(&tx.AuthList[i], expectedChainID)
    if !result.AuthVerifications[i].Valid {
        result.Valid = false
        return result  // ← 즉시 반환
    }
}
```

**EIP-7702 사양:**
```
유효하지 않은 튜플은 처리를 중단하고 다음 튜플로 계속 진행
같은 authority의 여러 튜플이 있으면 마지막 유효한 튜플 사용
```

---

## 4. 가스 계산 검증 ⚠️ 부분 구현

### 구현 현황

`gas.go`에서 EIP-7702 intrinsic 가스 계산이 구현되어 있습니다.

### 구현된 상수

| 상수 | 값 | 상태 |
|-----|-----|------|
| TxGas | 21,000 | ✅ |
| TxDataZeroGas | 4 | ✅ |
| TxDataNonZeroGas | 16 | ✅ |
| TxAccessListAddressGas | 2,400 | ✅ |
| TxAccessListStorageKeyGas | 1,900 | ✅ |
| PerAuthNewAccountGas | 25,000 | ✅ |
| PerAuthExistingRefund | 12,500 | ✅ |

### 테스트 케이스 (4개)

```go
✅ single_new_auth       // 21,000 + 25,000 = 46,000
✅ single_existing_auth  // 21,000 + 25,000 - 12,500 = 33,500
✅ two_auths_mixed       // 21,000 + 50,000 - 12,500 = 58,500
✅ auth_with_data        // 21,000 + 25,000 + (2×4) + (2×16) = 46,040
```

### 누락된 상수/계산

| 항목 | 값 | 상태 | 용도 |
|-----|-----|------|------|
| COLD_ACCOUNT_READ_COST | 2,600 | ❌ 미구현 | 콜드 계정 접근 시 |
| WARM_STORAGE_READ_COST | 100 | ❌ 미구현 | 웜 계정 접근 시 |

**참고:** 콜드/웜 계정 접근 비용은 위임 코드 해석 시 발생하며, 런타임에만 계산 가능합니다.

---

## 5. 네트워크 테스트 ✅ 완료

### 구현 현황

`network.go`에서 라이브 네트워크 테스트가 완벽하게 구현되어 있습니다.

### 구현된 기능

| 기능 | 함수 | 상태 |
|-----|------|------|
| RPC 클라이언트 | `NewNetworkTester()` | ✅ |
| 체인 ID 조회 | `getChainID()` | ✅ |
| 잔액 조회 | `GetBalance()` | ✅ |
| 논스 조회 | `GetNonce()` | ✅ |
| 코드 조회 | `GetCode()` | ✅ |
| 가스 가격 조회 | `GetGasPrice()` | ✅ |
| Prague 지원 확인 | `CheckPragueSupport()` | ✅ |
| SetCode 트랜잭션 전송 | `TestSetCodeTransaction()` | ✅ |
| 위임 코드 확인 | `TestDelegationCode()` | ✅ |
| 배치 실행 테스트 | `TestBatchExecution()` | ✅ |
| EIP-1559 트랜잭션 서명 | `signAndEncodeEIP1559Tx()` | ✅ |

### 테스트 흐름

```
1. Prague 포크 지원 확인
   └─ eth_chainId, eth_getBlockByNumber

2. 잔액 확인
   └─ eth_getBalance

3. SetCode 트랜잭션 테스트
   └─ 논스 조회 → 권한 부여 서명 → 트랜잭션 전송
   └─ 중요: auth.nonce = tx.nonce + 1 (self-broadcast)

4. 위임 코드 확인
   └─ eth_getCode → 0xef0100 접두사 검증

5. 배치 실행 테스트
   └─ executeBatch() 호출 → 다중 전송 검증
```

### 누락 항목

**없음** - 네트워크 테스트는 완벽하게 구현됨

---

## 6. 상수 정의 ✅ 완료

### 구현 현황

`constants.go`에서 EIP-7702 관련 상수들이 정의되어 있습니다.

### 정의된 상수

```go
DelegationPrefixLength     = 3      // 0xef0100 길이
DelegationCodeLength       = 23     // 접두사 + 주소
AuthorizationSigningPrefix = 0x05   // MAGIC 값
SetCodeTxType              = 0x04   // 트랜잭션 타입
CallNewAccountGas          = 25000  // PER_EMPTY_ACCOUNT_COST
TxAuthTupleGas             = 12500  // PER_AUTH_BASE_COST (환불)
PerEmptyAccountCost        = 25000  // 별칭
PerExistingAccountRefund   = 12500  // 별칭
```

---

## 권장 개선 사항

### 🔴 높은 우선순위 (보안 관련)

1. **s 값 범위 검증 추가**
   - EIP-2 준수 필수
   - `s <= secp256k1n/2` 확인
   - 악의적인 서명 공격 방지

2. **y_parity 검증 추가**
   - 0 또는 1만 허용
   - 잘못된 값 거부

3. **논스 범위 검증 추가**
   - `nonce < 2^64 - 1`
   - 오버플로우 방지

### 🟡 중간 우선순위

4. **위임 해제 테스트 추가**
   - 대상 주소가 `0x00...00`일 때 동작 검증
   - 코드 해시가 빈 코드 해시로 리셋되는지 확인

5. **중복 authority 처리**
   - 같은 authority의 여러 튜플 시 마지막만 적용
   - 현재는 처리 로직 없음

6. **유효하지 않은 튜플 스킵 로직**
   - 현재: 하나라도 실패하면 전체 실패
   - 사양: 실패한 튜플은 건너뛰고 계속 진행

7. **destination nil 검증 강화**
   - 컨트랙트 생성(nil destination) 명시적 거부

### 🟢 낮은 우선순위 (네트워크 상태 의존)

8. **콜드/웜 계정 접근 가스 계산**
   - 런타임 상태 필요
   - 시뮬레이션 시 사용

9. **계정 코드 상태 검증**
   - 네트워크 조회 필요
   - "비어있거나 이미 위임됨" 확인

10. **실시간 논스 일치 검증**
    - 네트워크 조회 필요
    - authority 현재 논스와 auth 논스 비교

---

## 결론

현재 EIP-7702 Inspector는 **핵심 기능**(위임 파싱, 서명 생성/검증, 트랜잭션 구조, 네트워크 테스트)이 잘 구현되어 있습니다.

그러나 **EIP-2 서명 검증**(`s` 값 범위)이 누락되어 있어 보안 관점에서 개선이 필요합니다. 또한 **에러 처리 로직**(유효하지 않은 튜플 스킵)이 EIP-7702 사양과 다르게 동작하고 있습니다.

### 즉시 개선 필요 항목
- `s` 값 범위 검증 (EIP-2)
- `y_parity` 검증
- 논스 범위 검증

### 향후 개선 고려 항목
- 유효하지 않은 튜플 스킵 로직
- 중복 authority 처리
- 위임 해제 테스트
